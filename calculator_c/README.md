# Calculator_c

Гибкая библиотека для вычисления математических выражений, написанная на чистом C.

## Возможности

- Синтаксический анализ и вычисление выражений
- Поддержка переменных
- Встроенные математические функции (sin, cos)
- Регистрация пользовательских операторов
- Обработка ошибок
- Кроссплатформенность (Linux, Windows)

## Структура проекта

```
calculator_c/
├── CMakeLists.txt             # Файл сборки CMake
├── README.md                  # Документация
├── include/                   # Заголовочные файлы
│   ├── calculator.h           # Основной публичный API
│   ├── lexer.h                # Лексический анализатор
│   ├── parser.h               # Синтаксический анализатор
│   ├── ast.h                  # Абстрактное синтаксическое дерево
│   └── evaluator.h            # Вычислитель выражений
├── src/                       # Исходный код
│   ├── calculator.c           # Реализация основного API
│   ├── lexer.c                # Реализация лексического анализатора
│   ├── parser.c               # Реализация синтаксического анализатора
│   ├── ast.c                  # Реализация АСД
│   └── evaluator.c            # Реализация вычислителя
├── examples/                  # Примеры использования
│   └── main.c                 # Пример консольного приложения
└── tests/                     # Тесты
    └── test_calculator.c      # Юнит-тесты
```

## Сборка

### Linux
```bash
mkdir build && cd build
cmake ..
make
```

### Windows (с использованием Visual Studio)
```bash
mkdir build && cd build
cmake .. -G "Visual Studio 16 2019"
cmake --build . --config Release
```

### Windows (с использованием MinGW)
```bash
mkdir build && cd build
cmake .. -G "MinGW Makefiles"
mingw32-make
```

## Использование библиотеки

### Базовый пример
```c
#include <calculator.h>
#include <stdio.h>

int main() {
    // Создание контекста калькулятора
    calculator_ctx_t* calc = calc_create();
    
    // Установка переменных
    calc_set_variable(calc, "x", 3.14159);
    calc_set_variable(calc, "y", 2.0);
    
    // Вычисление выражения
    double result;
    calc_error_t error = calc_evaluate(calc, "2 + sin(x) / {y + cos(x)} * PI", &result);
    
    if (error == CALC_SUCCESS) {
        printf("Результат: %f\n", result);
    } else {
        printf("Ошибка: %s\n", calc_get_error_message(error));
    }
    
    // Освобождение ресурсов
    calc_destroy(calc);
    return 0;
}
```

## Запуск консольного приложения

```bash
# Простое выражение
./calculator_c "2 + 2"

# Выражение с переменными
./calculator_c "2 + sin(x) / {y + cos(x)} * PI" --var x=3.14159 --var y=2

# Использование встроенной константы PI
./calculator_c "sin(PI/4)" --var PI=3.14159
```

## Поддерживаемые токены

### Операторы
- **Бинарные операторы**: `+` (сложение), `-` (вычитание), `*` (умножение), `/` (деление), `^` (возведение в степень)
- **Унарные операторы**: `-` (унарный минус), `!` (факториал)
- **Функции**: `sin`, `cos` и другие, которые могут быть добавлены пользователем

### Скобки
- Круглые скобки: `()`
- Фигурные скобки: `{}`
- Квадратные скобки: `[]`

### Константы
- `PI` = 3.1415926535 (требуется определить как переменную)

## Расширение функциональности

### Добавление новой унарной операции

Чтобы добавить новую унарную операцию (функцию), выполните следующие шаги:

1. Определите функцию, которая принимает один аргумент типа `double` и возвращает `double`:

```c
// Функция для вычисления квадрата числа
double square(double x) {
    return x * x;
}
```

2. Зарегистрируйте функцию в контексте калькулятора:

```c
calc_error_t error = calc_register_unary_op(calc, "square", square);
if (error != CALC_SUCCESS) {
    fprintf(stderr, "Не удалось зарегистрировать унарную операцию: %s\n", 
            calc_get_error_message(error));
    return 1;
}
```

3. Теперь функцию можно использовать в выражениях:

```c
double result;
calc_error_t error = calc_evaluate(calc, "square(5) + 2", &result);
// результат должен быть 27 (5² + 2 = 27)
```

#### Пример добавления функции тангенса

```c
#include <math.h>
#include <calculator.h>

// Шаг 1: Определение функции тангенса
double my_tan(double x) {
    return tan(x);
}

int main() {
    calculator_ctx_t* calc = calc_create();
    
    // Шаг 2: Регистрация функции
    calc_register_unary_op(calc, "tan", my_tan);
    
    // Шаг 3: Использование в выражении
    double result;
    calc_evaluate(calc, "tan(PI/4)", &result); // результат должен быть ~1.0
    
    printf("tan(PI/4) = %f\n", result);
    
    calc_destroy(calc);
    return 0;
}
```

### Добавление новой бинарной операции

Чтобы добавить новую бинарную операцию, выполните следующие шаги:

1. Определите функцию, которая принимает два аргумента типа `double` и возвращает `double`:

```c
// Функция для вычисления логарифма по произвольному основанию
double custom_log(double base, double x) {
    return log(x) / log(base);
}
```

2. Зарегистрируйте функцию в контексте калькулятора:

```c
calc_error_t error = calc_register_binary_op(calc, "log", custom_log);
if (error != CALC_SUCCESS) {
    fprintf(stderr, "Не удалось зарегистрировать бинарную операцию: %s\n", 
            calc_get_error_message(error));
    return 1;
}
```

3. Теперь функцию можно использовать в выражениях:

```c
double result;
calc_error_t error = calc_evaluate(calc, "log(10, 100)", &result);
// результат должен быть 2 (log₁₀(100) = 2)
```

#### Пример добавления операции остатка от деления

```c
#include <math.h>
#include <calculator.h>

// Шаг 1: Определение функции остатка от деления
double modulo(double a, double b) {
    return fmod(a, b);
}

int main() {
    calculator_ctx_t* calc = calc_create();
    
    // Шаг 2: Регистрация операции
    calc_register_binary_op(calc, "mod", modulo);
    
    // Шаг 3: Использование в выражении
    double result;
    calc_evaluate(calc, "mod(10, 3)", &result); // результат должен быть 1.0
    
    printf("10 mod 3 = %f\n", result);
    
    calc_destroy(calc);
    return 0;
}
```

## Коды ошибок и их обработка

Библиотека предоставляет следующие коды ошибок:

- `CALC_SUCCESS` (0) - операция выполнена успешно
- `CALC_ERROR_SYNTAX` - синтаксическая ошибка в выражении
- `CALC_ERROR_UNDEFINED_VAR` - использование неопределенной переменной
- `CALC_ERROR_INVALID_OPERATION` - недопустимая операция (например, деление на ноль)

### Пример обработки ошибок

```c
double result;
calc_error_t error = calc_evaluate(calc, "2 + * 3", &result);

if (error != CALC_SUCCESS) {
    const char* error_msg = calc_get_error_message(error);
    
    switch (error) {
        case CALC_ERROR_SYNTAX:
            fprintf(stderr, "Синтаксическая ошибка: %s\n", error_msg);
            break;
        case CALC_ERROR_UNDEFINED_VAR:
            fprintf(stderr, "Неопределенная переменная: %s\n", error_msg);
            break;
        case CALC_ERROR_INVALID_OPERATION:
            fprintf(stderr, "Недопустимая операция: %s\n", error_msg);
            break;
        default:
            fprintf(stderr, "Неизвестная ошибка: %s\n", error_msg);
    }
}
```

## Внутренняя архитектура

Библиотека использует следующие компоненты:

1. **Лексический анализатор** (lexer) - преобразует входную строку в последовательность токенов.
2. **Синтаксический анализатор** (parser) - строит абстрактное синтаксическое дерево (AST) из токенов.
3. **Вычислитель** (evaluator) - вычисляет значение выражения, обходя AST.

### Процесс вычисления выражения

1. Строка выражения передается в лексический анализатор.
2. Лексический анализатор разбивает строку на токены (числа, операторы, скобки, идентификаторы).
3. Синтаксический анализатор строит AST с учетом приоритетов операций.
4. Вычислитель обходит AST и вычисляет результат.

## Советы по расширению

### Добавление нового типа токенов

Для добавления нового типа токенов необходимо:

1. Добавить новый тип в перечисление `token_type_t` в файле `lexer.h`.
2. Модифицировать функцию `lexer_next_token()` в `lexer.c` для распознавания нового типа токенов.
3. Обновить синтаксический анализатор в `parser.c` для обработки нового типа токенов.

### Оптимизация производительности

- Для оптимизации часто используемых выражений рассмотрите возможность кэширования результатов.
- Для сложных вычислений рассмотрите возможность распараллеливания операций.

## Известные ограничения

- Максимальное количество переменных ограничено 100 (определено в `calculator.c`).
- Не поддерживаются многоаргументные функции (более двух аргументов).
- Не поддерживаются ассоциативные массивы или структуры данных.

## Лицензия

Этот проект распространяется по лицензии MY_OPENSRC
